- 说明：数据库是专门用来存储数据的。
- 注意：对于测试工作来说，如果项目页面没有实现，但我我们想要校验数据，则可以直接通过查询数据库实现。
- 关系：具体存在的商品录入后-->产生对应数据（存到数据库中）-->最后会被加载到项目中
### 数据库分类
1. 关系型数据库（RDMS）
数据之间的关系以数据库表的形式存在
![Pasted image 20250717094529.png](./images/Pasted%20image%2020250717094529.png)
关系型数据库的核心要素：
	数据行（一条记录）
	数据列（字段）
	数据表（数据行的集合）
	数据库（数据表的集合，一个数据库中有n个数据表）
2. 非关系型数据库
	没有数据表的概念，以键值对、文本、图片等形式存储的数据构成，比如Redis，MongoDB

### SQL语言
- 分类：
![Pasted image 20250717095400.png](./images/Pasted%20image%2020250717095400.png)
连接工具Navicat
由于数据库软件处于服务器中，想要操作数据库，就必须使用工具远程连接数据库后，进行操作
步骤：
	1. 数据库所在服务器的ip地址及数据库的端口号
	2. 向相关人员获取数据库的账号和密码
	3. 使用数据库连接工具，远程连接数据库即可
	注意：远程连接需要注意网络连通性
数据库的创建
![Pasted image 20250724094845.png](./images/Pasted%20image%2020250724094845.png)
注意：表内有数据时，不能去设计表，需要将所有的数据删除再设计

### 常见数据库类型
![Pasted image 20250724101516.png](./images/Pasted%20image%2020250724101516.png)
重点内容：
![Pasted image 20250724104436.png](./images/Pasted%20image%2020250724104436.png)
删除了也会有它对应id数的占用
### 约束
![Pasted image 20250724110220.png](./images/Pasted%20image%2020250724110220.png)
==如何设置唯一？==（不重复）
![Pasted image 20250724110516.png](./images/Pasted%20image%2020250724110516.png)
![Pasted image 20250724110617.png](./images/Pasted%20image%2020250724110617.png)
==如何设置默认值？==
![Pasted image 20250724110930.png](./images/Pasted%20image%2020250724110930.png)



### 创建和使用数据库


![Pasted image 20250724111506.png](./images/Pasted%20image%2020250724111506.png)
对应这里：
![Pasted image 20250724111551.png](./images/Pasted%20image%2020250724111551.png)
![Pasted image 20250724111440.png](./images/Pasted%20image%2020250724111440.png)使用数据库（切换数据库）：
	use 数据库名；
查看当前数据库：
	select 数据库名；
查看所有数据库：
	show databases;
修改数据库（或者直接鼠标右击点击编辑数据库）：
```
alter database 数据库名 
[default] character set <字符集名>
[default] collate <校对规则名>
```
删除数据库：
```
drop database 数据库名；
```
---
备份数据库：
在测试工作中，为了防止对数据库产生错误操作，或者==产生垃圾数据==（例如在自动化测试过程中，对注册模块产生的所有数据属于垃圾数据，应该清理），都需要在操作前，适当对数据库尽进行备份操作。
1. 利用工具：
一般选择字段加数据值
![Pasted image 20250724145129.png](./images/Pasted%20image%2020250724145129.png)
![Pasted image 20250724145240.png](./images/Pasted%20image%2020250724145240.png)
![Pasted image 20250724145714.png](./images/Pasted%20image%2020250724145714.png)
2. 使用命令进行备份
 注意：命令是不需要连接到数据库进行操作的
 如果使用 mysql -u -p数据库密码 是以命令行方式连接数据库，不能在mysql>下执行
备份数据库：
```
mysqldup =uroot -p 数据库名 > python.sql(是什么数据库就起什么名)
按照提示输入mysql的密码
```
恢复数据库：
```
mysql -uroot -p 新数据库名 < python.sql
```
### 数据表
创建表：
```
create table 表名（
字段名 类型 约束，
字段名 类型 约束，
...
）;
```
unsigned :无符号
primary key:主键
auto_increment:自动增长
扩展：判断表是否存在时，存在时先删除再创建,这样就可以多次运行
```
drop table if exists 表名;
```

---
通过navicat获取创表语句：
1. 直接在里面获取
![Pasted image 20250725111240.png](./images/Pasted%20image%2020250725111240.png)
2. 查看表信息
```
show create table 表名；
```
---
查看表结构（字段信息）：
```
desc 表名;
```
![Pasted image 20250725112212.png](./images/Pasted%20image%2020250725112212.png)
或者在命令台：
```
mysql - uroot -p
(输入密码)
use 数据库名;
desc 表名;
```
---
删除表：
drop table 表名；

### 数据操作
添加数据：
```
格式一(全部)：insert into 表名 values(...)
格式二(部分)：insert into 表名(字段1，字段2...) values (值1，值2...)
```
注意：
1. 数据值需要和字段一一对应
2. 主键列是自动增长，插入时需要占位，通常使用0或者default或者null来占位，插入成功后以实际数据为准
插入多行数据：
方法1：将单行插入语句，多句执行，每句分号隔开
![Pasted image 20250725121437.png](./images/Pasted%20image%2020250725121437.png)
方法2：写一条insert语句，设置多条数据，数据之间用英文逗号隔开
![Pasted image 20250725121732.png](./images/Pasted%20image%2020250725121732.png)

---
修改数据
```
update 表名 set 列1=值1，列2=值2 where 条件
```
说明：where不能省略，否则会修改整列数据

---
删除数据 ：
```
格式1：delete from 表名 where 条件;（删除所有数据，但是不重置主键字段的计数）
```
说明：where不能省略，否则会删除整列数据
扩展1：逻辑删除
单独设置字段isdelete,设置默认值0，如果要删除就将isdelete设置成1，没有真正的删除，只是标记为删除的数据，这样之后查询的时候可以不查询；可以通过update 表 set isdelete=1 where xxx;
![Pasted image 20250725124049.png](./images/Pasted%20image%2020250725124049.png)
扩展2：截断
```
格式2：truncate table 表名（删除表，所有数据和表结构都删除，重置主键字段的计数）
```
对比：![Pasted image 20250725124736.png](./images/Pasted%20image%2020250725124736.png)

---
查看所有数据库内容：show databases;
使用某个数据库：use test;
查看当前数据库：show database();
查看表：show tables;
查看表结构：desc tables;

---
### 查询
复杂查询：
	条件查询：按照一定条件筛选需要的结果
	排序：按照一定的排序规则筛选所需结果
	聚合函数：对一组数据进行计算得到一个结果的实现方法
	分组：在同一属性（字段）中，将值相同的放到一组的过程
	分页：对大批量数据进行设定数量展示的过程
	连接查询：将不同的表通过特定关系连接的过程
	自关联：将同一表通过特定关系连接的过程
	子查询：在一个查询套入另一个查询的过程
where后可跟：
	比较运算 =，！=，
	逻辑运算：and与 or或 not非
	模糊查询：like % 表示任意多个任意字符   _ 表示一个任意字符（可以在需要控制字符数量的时候使用）
	范围查询：
		in（...,...）
		between...and...(范围必须从小到大)
	空判断：
		注意：在MySQL中，只有显示为NULL的才为空！！其余空白可能是空格/制表符/换行符等空白符号
		is null   / is not null

### 排序
![Pasted image 20250728160528.png](./images/Pasted%20image%2020250728160528.png)
注意：排序过程中，支持连续设置多条排序规则，但离orderby关键字越近，排序数据的范围越大

### 聚合函数
1. 注意:聚合函数不能在where子句中使用
2. ( )中填写的是字段,如果统计数据总数,建议使用*,如果使用某一特定字段,可能会造成数据总数错误.(因为有空值)
3. 常见:
	 count():查询总记录数
	max():查询最发值
	min():查询最小值
	sum():求和
	avg():求平均值
4. 区分count 和sum
5. 在一条语句中,可以一次性适用所有聚合函数

### 分组
![Pasted image 20250728163816.png](./images/Pasted%20image%2020250728163816.png)
1. 与聚合函数搭配使用
2. group by :分组实现的结果,一般情况下,使用哪个字段进行分组,那么只有该字段可以在* 的位置处使用(用company分组,前面字段可以放company,否则只会显示最上面的,无意义)
![Pasted image 20250728164903.png](./images/Pasted%20image%2020250728164903.png)
3. 例子:如果直接select * from goods group by company;(那么显示的是该分组下,最上面的数据的内容,看不到具体的)
![Pasted image 20250728164336.png](./images/Pasted%20image%2020250728164336.png)

#### 分组过滤
![Pasted image 20250728165538.png](./images/Pasted%20image%2020250728165538.png)
![Pasted image 20250728170408.png](./images/Pasted%20image%2020250728170408.png)
having和where区别
- where是对from后面指定的表进行数据筛选，属于对原始数据的筛选
- having是对 group by的结果进行筛选
- having后面的条件中可以用聚合函数，where后面不可以

1. group by和having一般情况下需要配合使用
2. group by后边不推荐使用where进行条件过滤
3. having关键字后侧可以使用的内容与where完全一致（比较运算符/逻辑运算符/模糊查询/判断空）
4. having关键字后侧允许使用聚合函数

### 分页
![Pasted image 20250728181057.png](./images/Pasted%20image%2020250728181057.png)
limit :分页 ,start :起始行,count :数据行数
注意:计算机的计数从0开始,因此start默认的第一条数据为0;如果默认从第一条开始获取,可以直接把0省略.![Pasted image 20250728181656.png](./images/Pasted%20image%2020250728181656.png)

公式:已知每页显示m页,第n页数据内容:(需要自己算完)
```
select * from students limit (n-1)*m,m
```



全部:
```
-- 需求1：·准备商品数据，查询所有数据，查询部分字段，起字段别名，去重
-- 查询全部信息
	select * from goods;
-- 查询部分字段（逗号隔开）
	select goodsName,price from goods;
-- 其字段别名（引号可省，as可省）（除了给字段起别名，还可以给数据表起别名，在连接查询时可用）
	select goodsName as '商品名称',price as '商品价格' from goods;
	select goodsName 商品名称,price 商品价格 from goods;
-- 去重
	select distinct(company) from goods;
-- 补充题目：查询价格等于30但是不出自并夕夕的所有商品的信息（注意：not与and和or（左右两边连接条件）不同之处在于，not只对自己右侧的条件有作用(单边连接条件））
	select * from goods where price=30 and not company='并夕夕';

-- 需求2：查询价格等于30并且出自并夕夕的所有商品信息
	select * from goods where price=30 and company='并夕夕';
-- 需求3：查询全部一次性口罩的商品信息（注意具体内容需不需要前后都模糊）
	select *from goods where remark like '%一次性口罩%';
-- 需求4：查询所有价格在30-100的商品信息
	select * from goods where price>=30 and price<=100;
	select * from goods where price between 30 and 100;
-- 需求5：查询没有描述信息的商品信息
	select * from goods where remark is NULL;
-- 需求6：查询所有商品信息，按照价格从大到小排序，价格相同时，按照数量少到多排序
	select * from goods order by price desc,count asc;
-- 需求7：查询以下信息：商品信息总条数
	select count(*) from goods;
-- 最高商品价格
	select max(price) from goods;
-- 最低商品价格
	select min(price) from goods;
-- 商品平均价格
	select avg(price) from goods;
-- 一次性口罩的总数量
	select sum(count) from goods where remark like '%一次性口罩%';
-- 需求8：查询每家公司的商品信息数量
	select company,count(*) from goods group by company;
	select company,sum(count) from goods group by company having remark like '%一次性口罩%';
-- 需求9：查询当前表当中第5-10行的所有数据
	select * from goods limit 4,6;
-- 扩展:查询商品价格最贵的数据信息
	select * from goods order by price desc limit 0,1;
```

实际项目中数据库表的构成详细说明
![Pasted image 20250729131414.png](./images/Pasted%20image%2020250729131414.png)

### 连接查询
内连接/左连接/右连接/自关联
子查询:查询语句中包含另一个查询语句
数据库高级:数据库er模型/外键/索引

连接必须要有相对应的连接字段

![Pasted image 20250729185238.png](./images/Pasted%20image%2020250729185238.png)

内连接:
![Pasted image 20250729160003.png](./images/Pasted%20image%2020250729160003.png)
显示效果:两张表都有对应关系的数据会显示出来,没有对应关系的数据均不再显示
扩展:内连接的另一种写法
select *  from 表1,表2 where 表1.字段名=表2.字段名;
	select *  from goods,category where goods.typeId=category.typeId;

左连接:
![Pasted image 20250729164128.png](./images/Pasted%20image%2020250729164128.png)
注意:如果要保证一张表的全部数据都存在,则一定不能选择内连接,可以选择左连接或者右连接
说明:以left join 关键字为界,关键字左侧表为主表,而关键字右侧的表为从表,(对应内容显示,不对应的内容应为null)


右连接:
与左连接互反
以right join 关键字为界,关键字右侧表为主表,而关键字左侧的表为从表,(对应内容显示,不对应的内容应为null)

两者:那个在左边,那个的信息在左侧,否则相反
但是主表一定有,如果不对应从表位置显示null


存在左右连接的必要性
说明:能体现左右连接必要性的场景为:至少为三张表进行连接查询
可以根据这个例题考虑:
```
查询河南省的所有市和区
select * from areas a1 
left join areas a2 on a1.aid=a2.pid
left join areas a3 on a2.aid=a3.pid
where a1.atitle='河南省'
```

```
-- 需求1：查询所有存在商品分类的商品信息
	select * from goods inner join category on goods.typeId=category.typeId;
-- 可以起别名,简写;用别名给表创建副本
	 select * from goods go inner join category  ca on go.typeId=ca.typeId;
-- 需求2：查询所有商品信息，包含商品分类
	select * from goods left join category on goods.typeId=category.typeId;
-- 扩充需求:以分类为主展示所有内容
	select * from category left join goods on category.typeId=goods.typeId;
-- 需求3：查询所有商品分类及其对应的商品的信息
	select * from goods right join category on goods.typeId=category.typeId;
-- 扩展需求:查询所有商品信息及其对应分类信息
	select * from category right join goods on category.typeId=goods.typeId;
```

### 自关联
前提:
	1. 数据表只有一张
	2. 数据表中至少有两个字段有某种联系
方式:通过给表起别名的形式,将一张数据表变成两张,然后通过对应字段实现连接查询.
```
-- 需求4：查询河南省所有的市
-- 内连接
select * from areas a1 
inner join areas a2 on a1.aid=a2.pid
where a1.atitle='河南省';
-- 左连接
select * from areas a1 
left join areas a2 on a1.aid=a2.pid
where a1.atitle='河南省';
-- 需求5：查询河南省的所有的市和区
-- 三表联查

select * from areas a1 
left join areas a2 on a1.aid=a2.pid
left join areas a3 on a2.aid=a3.pid
where a1.atitle='河南省'
-- 需求6：查询价格高于平均价的商品信息
select avg(price) from goods 
select * from goods where price>(select avg(price) from goods);
-- 需求7：查询所有来自并夕夕的商品信息，包含商品分类
select * from goods go 
left join category ca on go.typeId=ca.typeId where company='并夕夕';
select * from (select go.*,ca.id cid,ca.typeId atid ,ca.cateName from goods go left join category ca on go.typeId=ca.typeId) new where new.company='并夕夕';

```

### 子查询
子查询：在一个select语句中，嵌入了另外一个select语句，那么嵌入的select语句称之为子查询语句
作用:子查询是辅助主查询的,要么充当条件,要么充当数据源
注意:充当子查询的语句需要使用括号括起来,运算优先级最高


### ER模型
E-R模型的基本元素是：实体、联系和属性
E表示entry，实体：描述具有相同特征事物的抽象(数据表)
属性：每个实体的具有的各种特征称为属性(表内字段)
R表示relationship，联系：实体之间存在各种关系，关系的类型包括包括一对一、一对多、多对
多(表与表的关系)
在navicat中打开
![Pasted image 20250730192410.png](./images/Pasted%20image%2020250730192410.png)

主键和外键
![Pasted image 20250730192503.png](./images/Pasted%20image%2020250730192503.png)
外键:
说明：通过外部数据表的字段，来控制当前数据表的数据内容变更，以避免单方面移除数据，导致关联表数据产生垃圾数据的一种方法
注意：如果大量增加外键设置，会严重影响除数据查询操作以外的其他操作（增/删/改）的操作效率，因此在实际项目中很少会被采用，但是在面试中容易被问到。

索引:
![Pasted image 20250730203052.png](./images/Pasted%20image%2020250730203052.png)
说明：可以大幅度提高查询语句的执行效率
注意：如果大量增加索引设置，会严重影响除数据查询操作以外的其他操作（增/删/改）的操作效率，不方便过多添加

