 注释:解释部分,增加可读性
python中的注释:
```
单行:使用井号空格进行注释,或者单独#也可以,快捷键 ctrl /,如果已经注释,再次使用快捷键,可以取消注释
多行注释:可以使用3对双引号或者3对单引号，被三对引号包括的内容就是注释的内容
```
三种波浪线:
红色:是错误,必须进行处理,否则无法执行.有些代码没写完也会红色
灰色:不会影响代码正常执行(PEP8：是Python代码的书写规范，如果不按照这个规范书写，会给灰色波浪线提示，建议代码的书写按照PEP8的规范书写)
	可以在书写完成之后，使用快捷键CtrlAltL来按照PEP8的规范自动格式化代码
绿色:绿色波浪线，不影响代码的正常执行，在引号中，认为你书写的内容不是一个单词，就会给你绿色提示

运行python代码三种途径
方法一:pycharm 直接打开;
方法二:cmd窗口打开,:python +文件位置
方法三:pycharm左下角(也是一个cmd窗口)
![Pasted image 20250728211631.png](./images/Pasted%20image%2020250728211631.png)

---
变量:
用来存储数据(在程序代码中出现的数据,想要保存下来,必须使用变量).
变量必须先定义(保存数据)后使用(取出数据)

定义变量:
变量名 =数据值 (将数据值保存到变量中)

变量名起名规范:
1. 必须字母数字下划线组成,不能以数字开头
2. 不能使用python中的关键字(下)
![Pasted image 20250728211903.png](./images/Pasted%20image%2020250728211903.png)

命名习惯:
1. 见名知义
2. 命名方法:
	1. 驼峰命名法
		- 大驼峰:每个单词的首字母大写'MyName'
		- 小驼峰:第一个单词的首字母大写,其余单词首字母大写'myName'
	2. 下划线连接法:每个单词之间使用下划线连接my_name
	python中的变量的定义使用的是下划线链接

变量的数据类型:
![Pasted image 20250729192622.png](./images/Pasted%20image%2020250729192622.png)
type( )函数:
	可以获取变量的数据类型
	type(变量)
	想要将这个类型在控制台输出,还需要print

输入
input()
1. 代码从上到下执行,遇到input()就会暂停执行,等待用户输入,如果不输入就会一直等待
2. 在输入过程中,遇到回车代表本次输入结束
3. 会将输入的内容保存到等号左边的变量中,并且变量的数据类型是str

类型转换
根据代码需要,将数据类型转换成另一种数据类型
变量=要转化的数据类型(原始数据)
1. 原来是什么类型
2. 要转换成什么类型
注意:数据类型转换,不会改变原来的数据类型,会生成一个新的数据类型
![Pasted image 20250731105930.png](./images/Pasted%20image%2020250731105930.png)

输出
1. 基本输出![Pasted image 20250731110304.png](./images/Pasted%20image%2020250731110304.png)
2. 格式化输出
![Pasted image 20250731111934.png](./images/Pasted%20image%2020250731111934.png)
正确写法:
```
print('我的名字是%s,我的年龄是%d,我的身高是%f'%(name,age,height))
```
占位符根据类型占位,后面写具体类型是%(内容1,内容2),按顺序写
小数默认显示六位,如果想要展示显示小数点后几位,用%.nf,n即为保留小数的位置
%.2f保留两位小数
补充1:
stu_num=1(想要显示为000001)
使用%0nd, n需要换成具体的整数数字,表示整数一共占几位
print('我的学号为%06d' %stu_num)
	不需要逗号隔开
补充2:
在书写时需要使用百分号,在书写时需要写2个百分号

f字符串方法
1.需要在字符串的前边加上f""或者F""
2.占位符号统一变为{ }
3．需要填充的变量写在{ }中
```
print(f'我的名字是{name},我的年龄是{age},我的身高是{height:.3f},我的学号是{stu_num:06d}')
```
如果有具体位数需求可以在{里面加:写}
换行符\n

字符串格式化
字符串.format(内容1,内容2)
```
print('我的名字是{},我的年龄是{},我的身高是{:.3f},我的学号是{:06d}'.format(name,age,height,stu_num))
```

运算符
![Pasted image 20250731130901.png](./images/Pasted%20image%2020250731130901.png)
优先级:不确定优先级就是用括号
```
() > ** > * / // % >+ -
```

比较运算符
```
> < >= <= == != 返回True或者False
```

逻辑运算符
and 逻辑与,并且 两个条件都为真,结果才为真(第一个条件为假,第二个不会执行)
or 或,只要一个为真,结果为真,当第一个为真,不再执行第二个
not 取反,真假改变

if判断
if elif else
![Pasted image 20250731201048.png](./images/Pasted%20image%2020250731201048.png)

if else
![Pasted image 20250731202959.png](./images/Pasted%20image%2020250731202959.png)

if elif else结构
![Pasted image 20250731203940.png](./images/Pasted%20image%2020250731203940.png)


Debug调试代码
![Pasted image 20250731204855.png](./images/Pasted%20image%2020250731204855.png)
![Pasted image 20250805161709.png](./images/Pasted%20image%2020250805161709.png)

在python中获取随机数
1.导入随机数工具包
	import random
2.使用工具包产生指定范围内随机数字
	random.randint(a,b) 会产生[a,b]之间的数字,闭区间
	
猜拳游戏(涉及if嵌套,随机数的获取):
![Pasted image 20250801133153.png](./images/Pasted%20image%2020250801133153.png)
循环结构:
while for

while循环
![Pasted image 20250801132200.png](./images/Pasted%20image%2020250801132200.png)
```
i=0  
while i<2:  
	print('我错了')  
	i+=1
```

死循环
![Pasted image 20250801132603.png](./images/Pasted%20image%2020250801132603.png)
![Pasted image 20250801132704.png](./images/Pasted%20image%2020250801132704.png)
可以循环且能结束的猜拳游戏![Pasted image 20250801133324.png](./images/Pasted%20image%2020250801133324.png)

 python中没有++和--,直接用+=,-=就行

for循环
![Pasted image 20250801204705.png](./images/Pasted%20image%2020250801204705.png)
 for range结合使用
 for 变量 in range(n):
	 重复执行的代码

```
range(n)是python中的函数,作用是可以生成[0,n) 的整数不包含n,一共循环n次,像循环几次,n就写几

range(a,b)是[a,b)的整数数字,不包含b
```

break和continue
只能在循环中使用
break终止循环,代码遇到break,循环不再执行,立即结束
continue跳过本次循环,本次循环剩下的代码不再执行,继续下一次循环
![Pasted image 20250802104927.png](./images/Pasted%20image%2020250802104927.png)
区别:假设输入的是cadb
如果这里是continue,那么会输出cd(会自动换行)
如果是break,那么在遇到a的时候就直接结束了,输出的是c

### 容器
容器:也可以称为数据序列,或者高级数据类型,也是python中的数据类型
容器可以存放多个数据
包含:字符串,列表,元组,字典


##### 字符串:
字符串的定义
```
使用引号引起来,单引号双引号三引号(单双都可以)都可以
字符串本身包含单引号,则定义时不能使用单引号"i'm 小明"
字符串本身包含双引号,则定义时不能使用双引号'i"m 小明'
如果非要用,那么可以在字符串里面用转义字符\加需要的引号'I\'m 小明' 会输出 i'm 小明
如果字符串里面非要有\这个符号
	那么加两个'i\\\'m 小明' 会输出 i\'m 小明
	或者字符串前面加r'字符串' ,那么字符串中的\不会被转义


```
下标(索引)
指字符在字符串中的位置编号,这个编号就是下标,一般从左到右进行编号,从0开始的,也可以是从右到左,从-1开始
![Pasted image 20250802111631.png](./images/Pasted%20image%2020250802111631.png)

求长度
len(str)
最后一个字符是str(len(str)-1)

切片:
![Pasted image 20250802123703.png](./images/Pasted%20image%2020250802123703.png)
如果最后一个也要取,str[4:],会默认从第五个到最后一个
特殊应用,步长为负数,开始和结束不屑,意思全部改变
应用场景:
反转(逆序)字符串,字符串[ : :-1]
![Pasted image 20250802130527.png](./images/Pasted%20image%2020250802130527.png)

字符串的查找
字符串.find(sub_str,start,end)
作用:在字符串中查找是否存在sub_str这样的字符串
sub_str:要查找的小的字符串`
start开始的位置,从那个下标开始查找,一般不写,默认是0
end:结束位置,查找到那个下标结束,一般不写,默认是len()
返回(代码执行之后会得到什么,如果有返回,空i可以使用变量保存)
	1. 如果在字符串中找到了sub_str,返回sub_str第一次出现的下标
	2. 如果没找到,会返回-1
如果我想知道第二个sub_str出现的位置,第二次开始的位置从第一个+1开始
![Pasted image 20250802132323.png](./images/Pasted%20image%2020250802132323.png)

字符串的替换
字符串.replace(old_str,new_str,count)
![Pasted image 20250802132859.png](./images/Pasted%20image%2020250802132859.png)
返回:替换之后的完整的字符串,原来的字符串不会发生改变!
```
str='good good sytrd'  
STR1=str.replace('g','G')  
print(STR1)  
str2=str.replace('good','GOOD',1)  
print(str2)
```


字符串的拆分
字符串.split(sep,map_split)将字符串按照sep进行拆分
![Pasted image 20250802182029.png](./images/Pasted%20image%2020250802182029.png)
```
str='good good sytrd'  
str1=str.split(maxsplit=1)  
print(str1)
```

字符串的连接
字符串.join(列表) 括号中的内容主要是列表,可以是其他容器
![Pasted image 20250802183014.png](./images/Pasted%20image%2020250802183014.png)
![Pasted image 20250802183308.png](./images/Pasted%20image%2020250802183308.png)(右边为输出结果)

字符的连接和字符的拆分是互逆的
![Pasted image 20250802183758.png](./images/Pasted%20image%2020250802183758.png)

### 列表
列表1ist，是使用最多的一种容器（数据类型）
列表中可以存储多个数据，每个数据之间使用逗号隔开
列表中可以存放任意类型的数据数字字符串都可以
![Pasted image 20250802200612.png](./images/Pasted%20image%2020250802200612.png)
列表支持下标和切片
列表支持下标和切片操作，使用方法和字符串中的使用方法一致
区别：列表的切片得到的是列表
![Pasted image 20250802201253.png](./images/Pasted%20image%2020250802201253.png)

查找-列表中数据下标的方法
![Pasted image 20250802201528.png](./images/Pasted%20image%2020250802201528.png)
#### 列表的查询
查找-判断是否存在
使用in关键字
	数据 in 容器 
	如果存在返回True,如果不存在返回False
查找-统计出现的次数
	使用count()方法
	列表.count(数据)  返回数据出现的次数
如果直接index(4)找不到会直接报错,一下两种方式更好
![Pasted image 20250802204111.png](./images/Pasted%20image%2020250802204111.png)
#### 列表的添加
尾部添加
	列表.append(数据)  将数据添加到列表的尾部
	返回:返回的是None,没啥意义,一般不返回接收
	想要查看添加后的列表,需要打印得是列表
指定下标位置添加
	列表.insert(下标,数据) 在指定位置添加数据,如果指定位置本来有数据,那么元数据会后移
	返回与尾部添加相同
列表合并
	列表1.extend(列表2)  将列表2中的所有数据逐个添加到列表2的尾部
	返回与尾部添加相同

![Pasted image 20250804160230.png](./images/Pasted%20image%2020250804160230.png)等价于![Pasted image 20250804160504.png](./images/Pasted%20image%2020250804160504.png)

#### 列表的修改
```
列表[下标]=数据

是列表特有的,只有列表可以这样通过下标修改,其他都没有
```

#### 列表的删除
- 根据下标删除
```
列表.pop(下标)

1. 下标不写时,回默认删除最后一个数据
2. 返回的是删除的数据(为数不多的有返回值的)
```
- 根据数据值删除
```
列表.remove(数据值)

1. 返回None
2. 列表中有多个该数据,只能删除第一个;如果想全部删除,可以利用循环进行删除
3. 注意:如果要删除的数据不存在,会报错
```
- 清空数据(一般不用)
```
列表.clear()

该列表会空,蛋不会完全删除列表
```

#### 列表的反转(倒置)
```
字符串中 字符串[::-1]

1. 列表[::-1]  列表中,也可以使用切片的方法,会得到一个新列表,原列表不发生改变
2. 列表.reverse()  直接修改原列表,返回None
```

#### 列表的复制
```
使用场景:有一个列表,需要修改操作列表中的数据,修改之后,需要和原数据进行对比,即原数据不能改

1. 使用切片 变量=列表[:]
2. 使用copy方法 变量=列表.copy()
```

#### 列表的排序
```
一般都是对数字进行排序的

列表.sort() 按照升序,从小到大
列表.sort(reverse=True) 就会进行降序排序
```

#### 列表的嵌套
列表嵌套,列表中的内容还是列表
```
person_info[["张三"，"18"，"功能测试"]，["李四"，"20"，"自动化测试"]]
可以通过person_info[0]来找到第一个列表
person_info[0][0]找到'张三'
可以对其进行修改删除等等
```

#### 列表去重
列表中存在多个数据,需求去重列表中重复的数据
![Pasted image 20250805170220.png](./images/Pasted%20image%2020250805170220.png)
![Pasted image 20250805170238.png](./images/Pasted%20image%2020250805170238.png)
![Pasted image 20250805165035.png](./images/Pasted%20image%2020250805165035.png)

### 元组
元组:tuple,元组的特点和列表非常相似
1. 元组中可以存放任意类型的数据
2. 元组中可以存放任意多个数据

区别:
1. 元组中的数据内容不能改变,列表中的可以改变
2. 元组使用( ),列表使用[ ]

应用:在函数的传参或者返回值中使用,保证数据不会被修改

定义:
1. 使用类实例化的方式
2. 直接使用( )的方式
![Pasted image 20250804172754.png](./images/Pasted%20image%2020250804172754.png)
![Pasted image 20250804172822.png](./images/Pasted%20image%2020250804172822.png)

常用方法
```
由于元组中的数据不能进行修改,所以只有查看的方法
1. 在元组中也可以使用下标和切片获取数据
2. 元组中也存在index方法
3. 也存在count方法
4. 也可以使用in操作
5. len()统计个数
以上方法的使用,和列表中时一样的
```

### 字典
1. 字典 dict ,字典中的数据是由键(key)值(value)对组成的(键表示数据的名字,值就是具体的数据)
2. 在字典中一组键值对就是一个数据,多个键值对之间使用逗号隔开
变量={key1:value1,key2:value2,...}
3. 一个字典中的键是唯一的,不能重复的,值是可以重复的,可以是任意数据
4. 字典中的键一般都是字符串,可以是数字,但不能是列表

#### 增加和修改操作
```
字典[键]=数据值

1. 如果键存在了,就是修改数据值
2. 如果键不存在,就是添加数据(即添加键值对)
3. 增加只能增加在最后,不能插入到前面
```
![Pasted image 20250804191221.png](./images/Pasted%20image%2020250804191221.png)
嵌套的使用
![Pasted image 20250804191149.png](./images/Pasted%20image%2020250804191149.png)

#### 删除
- 删除指定键值对
```
del 字典[键]
```
- 清空
```
字典.clear()
```
- 删除键
```
字典.pop('键')
```
嵌套的使用
![Pasted image 20250804191742.png](./images/Pasted%20image%2020250804191742.png)
#### 查询--根据键获取对应的值
字典中没有下标的概念,想要获取数据值,要使用key(键)来获取
```
使用 字典[键]
1. 如果键存在,返回键对应的数据值
2. 如果键不存在,会报错
```

```
使用字典.get(键)
字典.get(键,数据值)
1.数据值一般不写,默认是None
返回:
1. 如果键存在,返回键对应的数据值
2. 如果不存在,返回的是括号中书写的数据值(None)
```

#### 字典的遍历
- 对字典的键进行遍历
![Pasted image 20250804193137.png](./images/Pasted%20image%2020250804193137.png)
- 对字典的值进行遍历
![Pasted image 20250804193159.png](./images/Pasted%20image%2020250804193159.png)
- 对自带你的键值对进行遍历
![Pasted image 20250804193217.png](./images/Pasted%20image%2020250804193217.png)

![Pasted image 20250804193502.png](./images/Pasted%20image%2020250804193502.png)

容器部分总结部分
![Pasted image 20250804193942.png](./images/Pasted%20image%2020250804193942.png)


## 函数
就是把具有独立功能的代码块组织为一个模块,在需要时调用
通俗:将多行代码写在一起,起个名字,在需要这多行代码的时候,可以直接用这个名字代替
可以减少代码的冗余,提高编写效率
#### 函数的定义
1. 将多行代码放在一起起名字的过程,称为函数定义
2. 函数必须先定义后调用
```
def 函数名():
	代码

1. def是关键字,用来定义函数的,是define的缩写
2. 函数名需要遵守标识符的规则
3. 处于def缩进中的代码,称为函数体
4. 函数定义时,函数体中的代码不会执行,在调用时才会被执行
```

#### 函数的调用
1. 使用多行代码的时候,被称为函数的调用
```
函数名()

1. 函数调用时会执行函数体内的代码
2. 函数调用的代码,要写在函数体外面
```

文档注释:
在函数名下面,用三个引号进行注释
作用:告诉别人这个函数时如何使用的
查看时:在调用时,可以将光标放在函数名上,使用快捷键ctrl+q
按住ctrl然后鼠标右击函数,可以直接跳转到定义

#### 函数的嵌套调用
在一个函数定义中调用另一个函数
1. 函数定义不会执行函数体中的代码
2. 函数调用会执行函数体中的代码
3. 函数体中代码执行结束会回到函数被调用的地方继续向下执行

#### 函数的参数
![Pasted image 20250805192312.png](./images/Pasted%20image%2020250805192312.png)

#### 函数的返回值
函数的返回值可以理解为函数整体执行的结果是什么
函数得到的数据在后续的代码中还要使用,这个时候就应该将这个数据作为返回值返回,以供后续使用
在函数中想要将一个数据作为返回值返回,需要使用return关键字(只能在函数中使用)
作用:
	1. 将数据值作为返回值返回
	2. 函数代码执行遇到return,会结束函数的执行
  ![Pasted image 20250805195119.png](./images/Pasted%20image%2020250805195119.png)

### 变量进阶
变量的引用:
![Pasted image 20250807150956.png](./images/Pasted%20image%2020250807150956.png)
7. python中数据的传递,都是传递的引用
以下理解:
![Pasted image 20250807151613.png](./images/Pasted%20image%2020250807151613.png)

#### 可变类型和不可变类型
可变类型:列表 list ,字典 dict ,集合 set
	例如:列表.append( ),字典.pop(键)
不可变类型:int float bool str tuple

 列表是可变类型, ![Pasted image 20250807152343.png](./images/Pasted%20image%2020250807152343.png)
 id(my_list)没变,但是id(my_list[1])是改变了的

元组是不可变类型,下图中
![Pasted image 20250807152920.png](./images/Pasted%20image%2020250807152920.png)

#### 小题目理解
自己定义的my_list然后func(my_list),二函数中形参是list1,那么此时此刻,list和my_list的引用相同
题目一:![Pasted image 20250807153728.png](./images/Pasted%20image%2020250807153728.png)
题目二:
![Pasted image 20250807154126.png](./images/Pasted%20image%2020250807154126.png)
规律总结:
```
1.只有 = ，可以改变引用
2，可变类型做参数，在函数内部，如果不使用 = 直接修改形参的引用，对形参进行的数据修改会同步到实参中
```

题目三:
对于列表来说, += 的本质是extend操作
![Pasted image 20250807155103.png](./images/Pasted%20image%2020250807155103.png)

题目四:
交换两值
方法一:引入第三个变量中间过渡
方法二:
![Pasted image 20250807162909.png](./images/Pasted%20image%2020250807162909.png)
方法三:
a,b=b,a
就可以直接给两值交换,但是这个只限于python

组包和拆包
```
组包(pack):将多个数据值使用逗号连接,组成元组
拆包(unpack):将容器中数据值使用多个变量分别保留的过程,注意:变量的个数和容器中数据的个数要保持一致
赋值运算符,都是先执行灯好右边的代码,执行的结果,保存到等号的左边的变量中
```

#### 局部变量和全局变量
根据变量的定义位置,可以将变量分为局部变量和全局变量

局部变量
![Pasted image 20250807165745.png](./images/Pasted%20image%2020250807165745.png)

全局变量
![Pasted image 20250807170155.png](./images/Pasted%20image%2020250807170155.png)![Pasted image 20250807170624.png](./images/Pasted%20image%2020250807170624.png)
如果最后打印结果会是10,因为并没有调用函数进行修改

### 函数进阶
#### 函数返回值---函数返回多个数据值
方法:将多个数据值组成容器进行返回,一般是元组(组包)
![Pasted image 20250807171526.png](./images/Pasted%20image%2020250807171526.png)

#### 函数的参数
位置传参:在函数调用的时候，按照形参的顺序，将实参值传递给形参

关键字传参:在函数调用的时候，指定数据值给到那个形参

混合使用:
1. 关键字传参必须写在位置传参的==后面==
2. 不要给一个形参传递多个数据值
![Pasted image 20250807172750.png](./images/Pasted%20image%2020250807172750.png)

####  缺省参数(默认参数)
列表.pop( )   不写参数,就删除最后一个
列表.sort(reverse=True)    指定就降序,不指定就升序

1. 定义方式:在函数定义的时候，给形参一个默认的数据值，这个形参就变为缺省参数，注意，缺省参数的书写要放在普通参数的后边
2. 特点:
	缺省参数，在函数调用的时候，可以传递实参值，也可以不传递实参值
	如果传参，使用的就是传递的实参值;如果不传参，使用的就是默认值
![Pasted image 20250807173653.png](./images/Pasted%20image%2020250807173653.png)

#### 多值参数(可变参数/不定长参数)
![Pasted image 20250807194532.png](./images/Pasted%20image%2020250807194532.png)
![Pasted image 20250807194557.png](./images/Pasted%20image%2020250807194557.png)
示例:
![Pasted image 20250807194828.png](./images/Pasted%20image%2020250807194828.png)

##### 不定长参数的补充
函数传参中的拆包:
![Pasted image 20250808155156.png](./images/Pasted%20image%2020250808155156.png)
![Pasted image 20250808155143.png](./images/Pasted%20image%2020250808155143.png)

#### 匿名参数
使用lambda关键字定义的函数
而一般称使用def关键字定义的函数为标准函数

匿名函数只能书写一行代码
匿名函数的返回值不需要return,一行代码(表达式)的结果就是返回值
语法:
```
lambda 参数:一行代码

匿名函数一般不需要我们的主动的调用,一般作为函数的参数使用的
在学习阶段为了查看匿名函数定义的是否正确,可以调用
	1. 在定义的时候将匿名函数的引用保存到一个变量中
		变量=lambda 参数: 一行代码
	2. 使用变量进行调用
		变量()

```
无参无返回值:
```
func11=lambda :print('hello lambda')
func11()
```
无参有返回值:
```
func2=lambda 10
print(func2())
```
有参无返回值:
```
mysum3=lambda a,b:print(a+b)
mysum3(10,20)
```
有参有返回值:
```
func44=lambda a,b=a+b

print(func(10,20))
```
理解:![Pasted image 20250808164515.png](./images/Pasted%20image%2020250808164515.png)

#### 匿名函数的应用--列表中的字典排序
列表的排序，默认是对列表中的数据进行比大小的，可以对数字类型和字符串进行比大小，
但是对于字典来说，就不知道该怎么比大小，此时，我们需要使用sort函数中的key这个参数，来指定字典比大小的方法
key这个参数，需要传递一个函数，一般是匿名函数，字典的排序，其实要指定根据字典的什么键进行排序，我们只需要使用
匿名函数返回字典的这个键对应的值即可
```
列表.sort(key=lambda x=x['键'])
```
![Pasted image 20250808165307.png](./images/Pasted%20image%2020250808165307.png)
原理(不必必须理解):
![Pasted image 20250808170258.png](./images/Pasted%20image%2020250808170258.png)

获取对应ASCII码值:ord(字符)
获取对应字符:chr(ASCII码值)
字符串比大小:
	对应下标位置字符的大小,直到比出大小,如果全部比完了,还没比出大小,就是相等
![Pasted image 20250808171344.png](./images/Pasted%20image%2020250808171344.png)

---
